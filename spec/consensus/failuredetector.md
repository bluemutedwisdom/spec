*** This is the beginning of an unfinished draft. Don't continue reading! ***

# Failure detector

A failure detector is a process that connects to different Tendermint full nodes, requests headers from them, and then tries to verify and cross-check headers.

It uses the lite client algorithm to verify and trust headers, and then checks trusted headers against headers received from other full nodes.

Its prime purpose is to support fork accountability: In the case when more than 1/3 of the voting power is held by faulty validators, faulty nodes may generate two conflicting headers for the same height. The goal of the failure detector is to learn about the conflicting headers by probing different full nodes. Once a failure detector has two conflicting headers, these headers are evidence of misbehavior.



## Context of this document

The lite client specification is designed for the Tendermint failure model (1/3 assumption). It is safe and live under this assumption. If this assumption is violated, the lite client can be fooled to trust a header that was not generated by Tendermint consensus.

This specification, the failure detector, is a "second line of defense", in case the 1/3 assumption is violated. Its goal is to collect evidence. However,
for several reasons (in contrast to safety and liveness) we target probabilistic guarantees:

- it is impractical to probe all full nodes. That is, we will use random choices to decide which full node to probe next. As a result, there remains a probability that the full nodes that have a forged header are not probed (in time)
- even if we probe all full nodes, the adversary may hide forged headers from a full node until the failure detecter picks another full node.
**let's see what we can do about this...**

How this evidence is used will be discussed in another document. We may try to get the evidence on the main chain, which may work in practical scenarios. In theory, however,
given that the 1/3 assumption is violated, there are possible complications:

- evidence might be censored
- the faulty processes block all progress
- the faulty processes actually generated a fork and both branches make progress (with different correct processes participating in different branches)

This means that eventually we may need to fall back to social consensus. For this, the evidence of the fault detector will be crucial to figure out who misbehaved/what went wrong.


## Problem statement

## Definitions

## Specification

## Solution
